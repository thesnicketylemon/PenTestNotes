### American Fuzzy Lop (AFL)
Fuzzing requires a lot of patience. AFL creates a fork server and runs the test case on that server. AFL is a coverage-guided server.

Results:
1. Cycles done:
2. Total Paths:
3. Uniq Crashes:
4. Uniq Hangs:
5. Stage Progress: The most important part of the fuzzer, so that you can get an understanding of the speed of the fuzzer. You have to enhance the speed of the fuzzer if you want to get better results

#### Mutators / Fuzzing Strategies
1. **Calibration** - Pre-fuzzing stage where the execution path is examined
2. **Trim** - Pre-fuzzing stage where test case is trimmed to the shortest 
3. **Bitflip** - There are a number of bits being toggled at a given time in the input file
4. **Arith** - Tries to subtract or add small integers
5. **Interest** - Fuzzer has an interesting number of bits to try
6. **Extras**
7. **Havoc**
8. **Splice**
9. **Sync**
10. **Flip**

AFL does Flip, Splice, Trim and repeat.

### Custom Mutators

### When do you stop a fuzzer?
For AFL, wait at least for one cycle to be done before doing a  Ctrl+C on it

### Using AFL

AFL needs programs that are compiled using the AFL compiler `afl-gcc`

### Network Fuzzing

### Questions
1. How does AFL determine if a crash is unique?
2. What is the pending favorite?
3. What's the difference between pre-fuzzing and fuzzing?
	1. Pre-fuzzing is just a dry run that the corpus is working with the fuzzer and the fork server 
4. How does this persistence happen? What is the optimization that makes it run so fast?
5. Read the whitepaper on SYMBB

### Tools
Use `nm` to get information about a C function
Use `apt-cache search` to find a package in apt
Use `radamsa` to generate the corpus https://gitlab.com/akihe/radamsa
Network Protocol Fuzzzer - https://github.com/wireghoul/doona, https://boofuzz.readthedocs.io/en/stable/user/install.html#id1
QEMU

https://huntr.dev/