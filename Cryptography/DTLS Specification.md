TLS RFC: https://www.rfc-editor.org/rfc/rfc5246
DTLS RFC: https://datatracker.ietf.org/doc/html/rfc6347


### TLS Record Protocol
The Record Protocol takes messages to be transmitted, fragments the data into manageable blocks, optionally compresses the data, applies a MAC, encrypts, and transmits the result. This is called a TLS Record.

Received data is decrypted, verified, decompressed, reassembled, and then delivered to higher-level clients.

There are four protocols that use the Record Protocol. They are differentiated by a record
1. Handshake Protocol
2. Alert Protocol
3. Change Cipher Spec Protocol
4. Application Data Protocol

#### MUST NOT
1. Implementations MUST NOT send record types not defined unless negotiated by some extension. So if a TLS implementation receives an unexpected record type, it MUST send an `unexpected_message` alert.
2. Implementations MUST NOT send zero-length fragments of Handshake, Alert, or ChangeCipherSpec content types. 
3. Each AEAD cipher suite MUST specify how the nonce supplied to the AEAD operation is constructed, and what is the length of the GenericAEADCipher.nonce_explicit part


#### ChangeCipherSpec

#### Master Secret
A 48-byte secret shared between the two peers in the connection.

#### Client Random
A 32-byte value provided by the client.

#### Server Random
A 32-byte value provided by the server.

#### Sequence Number
 Each connection state contains a sequence number, which is maintained separately for read and write states.  The sequence number MUST be set to zero whenever a connection state is made the active state.  Sequence numbers are of type uint64 and may not exceed 2^64-1.  Sequence numbers do not wrap.  If a TLS implementation would need to wrap a sequence number, it must renegotiate instead.
