TLS RFC: https://www.rfc-editor.org/rfc/rfc5246
DTLS RFC: https://datatracker.ietf.org/doc/html/rfc6347


### TLS Record Protocol
The Record Protocol takes messages to be transmitted, fragments the data into manageable blocks, optionally compresses the data, applies a MAC, encrypts, and transmits the result. This is called a TLS Record.

Received data is decrypted, verified, decompressed, reassembled, and then delivered to higher-level clients.

There are four protocols that use the Record Protocol. They are differentiated by a record
1. Handshake Protocol
2. Alert Protocol
3. Change Cipher Spec Protocol
4. Application Data Protocol

#### MUST NOT
1. Implementations MUST NOT send record types not defined unless negotiated by some extension. So if a TLS implementation receives an unexpected record type, it MUST send an `unexpected_message` alert.
2. Implementations MUST NOT send zero-length fragments of Handshake, Alert, or ChangeCipherSpec content types. 
3. Each AEAD cipher suite MUST specify how the nonce supplied to the AEAD operation is constructed, and what is the length of the GenericAEADCipher.nonce_explicit part

   Note: Attacks discovered by Bleichenbacher [[BLEI](https://www.rfc-editor.org/rfc/rfc5246#ref-BLEI ""Chosen Ciphertext Attacks against Protocols Based on RSA Encryption Standard PKCS #1"")] and Klima et al.
   [[KPR03](https://www.rfc-editor.org/rfc/rfc5246#ref-KPR03 ""Attacking RSA-based Sessions in SSL/TLS"")] can be used to attack a TLS server that reveals whether a
   particular message, when decrypted, is properly PKCS#1 formatted,
   contains a valid PreMasterSecret structure, or has the correct
   version number.

   As described by Klima [[KPR03](https://www.rfc-editor.org/rfc/rfc5246#ref-KPR03 ""Attacking RSA-based Sessions in SSL/TLS"")], these vulnerabilities can be avoided
   by treating incorrectly formatted message blocks and/or mismatched
   version numbers in a manner indistinguishable from correctly
   formatted RSA blocks.  In other words:

      1. Generate a string R of 46 random bytes

      2. Decrypt the message to recover the plaintext M

      3. If the PKCS#1 padding is not correct, or the length of message
         M is not exactly 48 bytes:
            pre_master_secret = ClientHello.client_version || R
         else If ClientHello.client_version <= TLS 1.0, and version
         number check is explicitly disabled:
            pre_master_secret = M
         else:
            pre_master_secret = ClientHello.client_version || M[2..47]
          It is a fatal error if a Finished message is not preceded by a
   ChangeCipherSpec message at the appropriate point in the handshake.

CloudHSM Specific: https://www.rfc-editor.org/rfc/rfc5246#section-7.4.7.1

Recipients of Finished
      messages MUST verify that the contents are correct.  Once a side
      has sent its Finished message and received and validated the
      Finished message from its peer, it may begin to send and receive
      application data over the connection.

#### ChangeCipherSpec Protocol
Consists of only one message â€“ is used to indicate the start of the use of established session keys

#### Master Secret
A 48-byte secret shared between the two peers in the connection.

#### Client Random
A 32-byte value provided by the client.

#### Server Random
A 32-byte value provided by the server.

#### Sequence Number
 Each connection state contains a sequence number, which is maintained separately for read and write states.  The sequence number MUST be set to zero whenever a connection state is made the active state.  Sequence numbers are of type uint64 and may not exceed 2^64-1.  Sequence numbers do not wrap.  If a TLS implementation would need to wrap a sequence number, it must renegotiate instead.
